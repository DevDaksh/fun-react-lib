{"version":3,"sources":["docs/infinite-scroll.md","components/InfiniteScroll/InfiniteScroll.js","demos/InfiniteScrollDemo.js"],"names":["module","exports","InfiniteScroll","children","hasMore","isLoading","isError","triggerFunction","loadingComponent","errorComponent","observerNode","useRef","useEffect","observer","IntersectionObserver","entries","isIntersecting","rootMargin","observe","current","disconnect","id","ref","getUsers","currentPage","results","a","fetch","res","json","data","InfiniteScrollDemo","useState","markdown","setMarkdown","infiniteScrollPath","then","text","initialState","setData","page","setPage","setHasMore","setIsLoading","setIsError","cancel","concat","catch","useFetchUsers","Fragment","source","map","d","i","key","name","title","first","last","cell","email"],"mappings":"yGAAAA,EAAOC,QAAU,IAA0B,4C,0GC8C5BC,EA5CQ,SAAC,GAQjB,IAPNC,EAOK,EAPLA,SACAC,EAMK,EANLA,QACAC,EAKK,EALLA,UACAC,EAIK,EAJLA,QACAC,EAGK,EAHLA,gBAGK,IAFLC,wBAEK,MAFc,KAEd,MADLC,sBACK,MADY,KACZ,EACCC,EAAeC,mBAyBrB,OAvBAC,qBAAU,WACT,IAAIP,IAAaC,EAAjB,CAIA,IAAMO,EAAW,IAAIC,sBACpB,SAAAC,GACKA,EAAQ,GAAGC,gBAAkBZ,GAChCG,MAGF,CACCU,WAAY,oBAMd,OAFAJ,EAASK,QAAQR,EAAaS,SAEvB,WACNN,EAASO,iBAER,CAACf,EAAWC,EAASF,EAASG,EAAiBG,IAGjD,6BACEP,EACD,yBAAKkB,GAAG,8BAA8BC,IAAKZ,IAC1CL,GAAaG,EACbF,GAAWG,I,kBCjCTc,EAAQ,uCAAG,WAAOC,EAAaC,GAApB,iBAAAC,EAAA,sEACEC,MAAM,GAAD,OAHH,4BAGG,kBAA0BH,EAA1B,oBAAiDC,IADxD,cACVG,EADU,gBAEGA,EAAIC,OAFP,cAEVC,EAFU,yBAGTA,EAAKL,SAHI,2CAAH,wDAiGCM,UAlDY,WAAO,IAAD,EACAC,mBAAS,IADT,mBACzBC,EADyB,KACfC,EADe,KAGhCtB,qBAAU,WACTe,MAAMQ,KACJC,MAAK,SAAAR,GAAG,OAAIA,EAAIS,UAChBD,MAAK,SAAAC,GACLH,EAAYG,SAPiB,MAzCX,SAAAC,GAAiB,IAAD,EACbN,mBAASM,EAAaR,MADT,mBAC9BA,EAD8B,KACxBS,EADwB,OAEbP,mBAASM,EAAaE,MAFT,mBAE9BA,EAF8B,KAExBC,EAFwB,OAGPT,mBAASM,EAAalC,SAHf,mBAG9BA,EAH8B,KAGrBsC,EAHqB,OAIHV,mBAASM,EAAajC,WAJnB,mBAI9BA,EAJ8B,KAInBsC,EAJmB,OAKPX,mBAASM,EAAahC,SALf,mBAK9BA,EAL8B,KAKrBsC,EALqB,KAgCrC,OAzBAhC,qBAAU,WACT,IAAIiC,GAAS,EAmBb,OAjBAF,GAAa,GACbC,GAAW,GAEXrB,EAASiB,EAAM,IACbJ,MAAK,SAAAR,GACAiB,IACJN,GAAQ,SAAAT,GAAI,OAAIA,EAAKgB,OAAOlB,MAC5Be,GAAa,GACbC,GAAW,GACXF,GAAW,OAGZK,OAAM,WACNH,GAAW,GACXD,GAAa,MAGR,WACNE,GAAS,KAER,CAACL,IAEG,CACNV,OACAW,UACArC,UACAC,YACAC,WAesD0C,CAAc,CACpElB,KAAM,GACNU,KAAM,EACNpC,SAAS,EACTC,WAAW,EACXC,SAAS,IALFwB,EAXwB,EAWxBA,KAAMW,EAXkB,EAWlBA,QAASrC,EAXS,EAWTA,QAASC,EAXA,EAWAA,UAAWC,EAXX,EAWWA,QAQ3C,OACC,kBAAC,IAAM2C,SAAP,KACC,kBAAC,IAAD,CAAeC,OAAQjB,IACvB,6BACC,4CACA,kBAAC,EAAD,CACC7B,QAASA,EACTC,UAAWA,EACXC,QAASA,EACTC,gBAAiB,WAChBkC,GAAQ,SAAAD,GAAI,OAAIA,EAAO,MAExBhC,iBAAkB,yCAClBC,eAAgB,mDAEfqB,EAAKqB,KAAI,SAACC,EAAGC,GACb,OACC,yBAAKC,IAAKD,GACT,sCAAQD,EAAEG,KAAKC,MAAf,aAAyBJ,EAAEG,KAAKE,MAAhC,YAAyCL,EAAEG,KAAKG,OAChD,2BACEN,EAAEO,KADJ,MACaP,EAAEQ","file":"static/js/6.17087e83.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/infinite-scroll.76a4df80.md\";","import React, { useRef, useEffect } from 'react';\r\n\r\nconst InfiniteScroll = ({\r\n\tchildren,\r\n\thasMore, // Required: Specifies if there are more entities to load\r\n\tisLoading, // Required: Specifies if the current state of the app is loading. If true and a loadingComponent was passed, it will be shown\r\n\tisError, // Required: Specifies if an error ocurred. If true and an errorComponent was passed, it will be shown\r\n\ttriggerFunction, // Required: When the last element is visible, it will trigger the passed function.\r\n\tloadingComponent = null,\r\n\terrorComponent = null,\r\n}) => {\r\n\tconst observerNode = useRef();\r\n\r\n\tuseEffect(() => {\r\n\t\tif (isLoading || isError) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst observer = new IntersectionObserver(\r\n\t\t\tentries => {\r\n\t\t\t\tif (entries[0].isIntersecting && hasMore) {\r\n\t\t\t\t\ttriggerFunction();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\trootMargin: '10% 0px 10% 0px',\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tobserver.observe(observerNode.current);\r\n\r\n\t\treturn () => {\r\n\t\t\tobserver.disconnect();\r\n\t\t};\r\n\t}, [isLoading, isError, hasMore, triggerFunction, observerNode]);\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t{children}\r\n\t\t\t<div id=\"infinite-scrolling-observer\" ref={observerNode}></div>\r\n\t\t\t{isLoading && loadingComponent}\r\n\t\t\t{isError && errorComponent}\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nexport default InfiniteScroll;\r\n","import React, { useState, useEffect } from 'react';\r\nimport ReactMarkdown from 'react-markdown';\r\n\r\nimport InfiniteScroll from '../components/InfiniteScroll/InfiniteScroll';\r\nimport infiniteScrollPath from '../docs/infinite-scroll.md';\r\n\r\nconst API_BASE_URL = 'https://randomuser.me/api';\r\n\r\nconst getUsers = async (currentPage, results) => {\r\n\tconst res = await fetch(`${API_BASE_URL}/?page=${currentPage}&results=${results}`);\r\n\tconst data = await res.json();\r\n\treturn data.results;\r\n};\r\n\r\nconst useFetchUsers = initialState => {\r\n\tconst [data, setData] = useState(initialState.data);\r\n\tconst [page, setPage] = useState(initialState.page);\r\n\tconst [hasMore, setHasMore] = useState(initialState.hasMore);\r\n\tconst [isLoading, setIsLoading] = useState(initialState.isLoading);\r\n\tconst [isError, setIsError] = useState(initialState.isError);\r\n\r\n\tuseEffect(() => {\r\n\t\tlet cancel = false;\r\n\r\n\t\tsetIsLoading(true);\r\n\t\tsetIsError(false);\r\n\r\n\t\tgetUsers(page, 10)\r\n\t\t\t.then(res => {\r\n\t\t\t\tif (!cancel) {\r\n\t\t\t\t\tsetData(data => data.concat(res));\r\n\t\t\t\t\tsetIsLoading(false);\r\n\t\t\t\t\tsetIsError(false);\r\n\t\t\t\t\tsetHasMore(true);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.catch(() => {\r\n\t\t\t\tsetIsError(true);\r\n\t\t\t\tsetIsLoading(false);\r\n\t\t\t});\r\n\r\n\t\treturn () => {\r\n\t\t\tcancel = true;\r\n\t\t};\r\n\t}, [page]);\r\n\r\n\treturn {\r\n\t\tdata,\r\n\t\tsetPage,\r\n\t\thasMore,\r\n\t\tisLoading,\r\n\t\tisError,\r\n\t};\r\n};\r\n\r\nconst InfiniteScrollDemo = () => {\r\n\tconst [markdown, setMarkdown] = useState('');\r\n\r\n\tuseEffect(() => {\r\n\t\tfetch(infiniteScrollPath)\r\n\t\t\t.then(res => res.text())\r\n\t\t\t.then(text => {\r\n\t\t\t\tsetMarkdown(text);\r\n\t\t\t});\r\n\t});\r\n\r\n\tconst { data, setPage, hasMore, isLoading, isError } = useFetchUsers({\r\n\t\tdata: [],\r\n\t\tpage: 1,\r\n\t\thasMore: true,\r\n\t\tisLoading: false,\r\n\t\tisError: false,\r\n\t});\r\n\r\n\treturn (\r\n\t\t<React.Fragment>\r\n\t\t\t<ReactMarkdown source={markdown} />\r\n\t\t\t<div>\r\n\t\t\t\t<h2>My User List</h2>\r\n\t\t\t\t<InfiniteScroll\r\n\t\t\t\t\thasMore={hasMore}\r\n\t\t\t\t\tisLoading={isLoading}\r\n\t\t\t\t\tisError={isError}\r\n\t\t\t\t\ttriggerFunction={() => {\r\n\t\t\t\t\t\tsetPage(page => page + 1);\r\n\t\t\t\t\t}}\r\n\t\t\t\t\tloadingComponent={<p>loading...</p>}\r\n\t\t\t\t\terrorComponent={<p>An error ocurred...</p>}\r\n\t\t\t\t>\r\n\t\t\t\t\t{data.map((d, i) => {\r\n\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t<div key={i}>\r\n\t\t\t\t\t\t\t\t<h3>{`${d.name.title}. ${d.name.first} ${d.name.last}`}</h3>\r\n\t\t\t\t\t\t\t\t<p>\r\n\t\t\t\t\t\t\t\t\t{d.cell} - {d.email}\r\n\t\t\t\t\t\t\t\t</p>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t})}\r\n\t\t\t\t</InfiniteScroll>\r\n\t\t\t</div>\r\n\t\t</React.Fragment>\r\n\t);\r\n};\r\n\r\nexport default InfiniteScrollDemo;\r\n"],"sourceRoot":""}